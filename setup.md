# 環境構築

まず、プログラミングを始めるまでの環境構築を比較してみましょう。

## Ruby の場合

Rubyの場合は、`apt` などのOSが用意したパッケージは古いので、
`rbenv` や `rvm` などのバージョンマネージャを使うことがほとんどです。
手元のマシンや、デプロイ先も(たとえ使うRubyのバージョンが1つでも)基本的にバージョンマネージャを使います[^1]。

バージョンマネージャを使う利点は、処理系のバージョンが変更しやすいことだけではありません。

- $HOME以下で完結している
- 複数環境が共存する仕組みが整えられている
- インストールが自動化されている

特に、ユーザの所有物として処理系がインストールできるのは革命的でした。
昔は `bundler` がなかったので、gemをプロジェクト内の `vendor/bundle` にインストールするようなことはできなかったのです。
昔々、人類がまだパッケージでインストールした `/usr/bin/ruby` などを使っている時代、 人々はgemをインストールするのに、

    sudo gem install rails

のように **管理者権限が必要だった** のです[^2]。
今では、

    gem install rails

とやれば `$HOME/.rbenv` 以下にインストールされるようになっています。

実は `apt` のRubyを使いたくない理由のひとつは、バージョンの古さというより、このあたりの取り回しの悪さにあります。

それ以前に、同じようなことをしたい場合、ソースコードをダウンロードし、
自力でコンパイルする必要がありました。

    $ ./configure --prefix $HOME/ruby-2.6.5
    $ make
    $ make install

もちろん、これだけではバージョンを切り替える仕組みはありません。

バージョンマネージャを使うことで、何も面倒なことを考えること無く、
**望むバージョンのRubyがすぐに手に入る** のです。


[^1]: 最近はDockerの場合も増えてきた
[^2]: このため共有型レンタルサーバでRubyを使うのは絶望的だった

## 他の言語の場合

`rbenv` の成功によって、他の多くの言語にも `*env` が作られました。
世はまさに大\*env時代、 様々な `*env` を一括管理できる [anyenv](https://github,com/anyenv/anyenv) というものまで生まれ、 今後は(rbenvを含めて) `anyenv` を通して色々な言語をインストールするのが主流になるでしょう。
rubyはもちろん, node, python, go, php などが一括インストールできます。

さて、これで本当に環境構築は楽になったのでしょうか。

### Pythonの場合

Pythonには今でもバージョン2と3の分断が存在します。
まぁこれは両方入れればいいでしょう。
Linuxの様々なツールはPythonで書かれており、システムのPythonと分離できるという点で、Pythonほど `\*env` の恩恵を受けている言語は無いと言ってもいいと思います。
`pip` でインストールしたパッケージも、anyenvの下にバージョンごとにわけられて配置されます。

### PHPの場合

PHPでは、anyenv のディレクトリ下に相変わらず **php.ini** が存在します。
処理系の動作に設定ファイルがあるのは、**控えめに言って地獄** なのは嫌というほど知っているでしょう。
(まず弄ることがないとしても)

また、PHPのパッケージシステムといえば `composer` ですが、このインストール方法が本当にひどく、phpenvの世界ではどうするべきかまだデファクトがなさそうです[^3。

PHPに関しては環境構築がそれほど簡単ではないと言えるでしょう。

[^3]: `ngyuki/phpenv-composer` というプラグインがあったけどStarが15でメジャーではなさそう

### GOの場合

GOは、元々 **コンパイル済みバイナリをダウンロードする** というマッチョなインストール[^4]だったんですが、インストールが自動化されることでそのマッチョさを見なくて済むようになったのが大きな利点です。
GOはCLIコマンドを作るのに人気という利用目的から、 `go get` で **PATHの通ったところにバイナリファイルをビルドできる** ことが重要ですが、GOのバージョンに関係なくソースのダウンロードやビルドの配置は `$GOPATH` を基準に行われるので、ビルド成果物がanyenvの中に隠されるようなことはなさそうです。

ただ、GOは `$GOPATH` を設定したり、必要な環境変数がバージョンごとに変化していたり、最近 **modules** が導入されてまだ過渡期にあったり、そのあたり色々つらい状況だなと感じます。

[^4]: GO自体もそのようなポータブルなバイナリを吐くのでそういう思想なんだろう

### Nodeの場合

Nodeは `nodenv` で簡単にインストールでき、同時に `npm` もインストールできるので便利です。
が、Nodeの場合は **ここからが非常に大変** です。
babelやらwebpackやら、正しくセットアップできる人類は存在するんでしょうか?
また、ライブラリの栄枯盛衰が激しすぎて、**今は** どのライブラリを使うのが正解なのか、常に追いかけていないとわからないと言う問題もあります。
処理系のインストールは簡単だけど、コードを書き始めるまでにはめちゃめちゃ時間がかかると感じました。

## 環境構築のまとめ

Rubyは、rbenvを使うことで非常に簡単にインストールでき、設定ファイルなども無いので、全人類がほとんど差異のないRubyを使っています。
また、rbenvが発明された土壌というものから想像できると思いますが、 **多くの人が最新のRubyを使っています**。

そして `bundler` や `rake` など、開発に必要な基本的なツールは **本体に** 揃っているので、すぐに開発を始められます。
また、混乱の元になるようなツールの乱立はあまり起こりません[^5]。

これらの特徴から、Rubyの開発はスタートまで一切迷うところがありません。
Rubyistはそういうところが楽だと思っています。

多言語も\*envの文化が輸出されたことで随分インストールは楽になりました。
しかし、特にNodeに見られるようなツール同士の複雑な依存関係のセットアップや、
ツールの乱立による混乱[^6]に対して、Rubyistはめんどくささを強く感じます。

[^5]: その時期ははるか昔に過ぎた
[^6]: Nodeはいつになったら「その時期」が終わるんだ?
